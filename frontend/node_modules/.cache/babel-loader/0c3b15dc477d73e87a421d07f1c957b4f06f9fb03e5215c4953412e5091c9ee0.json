{"ast":null,"code":"import _objectSpread from \"/home/spiderman/tek2/project-week/Pet-Wise/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/spiderman/tek2/project-week/Pet-Wise/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"children\"],\n  _excluded2 = [\"children\"];\n// packages/react/slot/src/Slot.tsx\nimport * as React from \"react\";\nimport { composeRefs } from \"@radix-ui/react-compose-refs\";\nimport { Fragment, jsx } from \"react/jsx-runtime\";\nvar Slot = React.forwardRef((props, forwardedRef) => {\n  const {\n      children\n    } = props,\n    slotProps = _objectWithoutProperties(props, _excluded);\n  const childrenArray = React.Children.toArray(children);\n  const slottable = childrenArray.find(isSlottable);\n  if (slottable) {\n    const newElement = slottable.props.children;\n    const newChildren = childrenArray.map(child => {\n      if (child === slottable) {\n        if (React.Children.count(newElement) > 1) return React.Children.only(null);\n        return React.isValidElement(newElement) ? newElement.props.children : null;\n      } else {\n        return child;\n      }\n    });\n    return /* @__PURE__ */jsx(SlotClone, _objectSpread(_objectSpread({}, slotProps), {}, {\n      ref: forwardedRef,\n      children: React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null\n    }));\n  }\n  return /* @__PURE__ */jsx(SlotClone, _objectSpread(_objectSpread({}, slotProps), {}, {\n    ref: forwardedRef,\n    children\n  }));\n});\nSlot.displayName = \"Slot\";\nvar SlotClone = React.forwardRef((props, forwardedRef) => {\n  const {\n      children\n    } = props,\n    slotProps = _objectWithoutProperties(props, _excluded2);\n  if (React.isValidElement(children)) {\n    const childrenRef = getElementRef(children);\n    return React.cloneElement(children, _objectSpread(_objectSpread({}, mergeProps(slotProps, children.props)), {}, {\n      // @ts-ignore\n      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef\n    }));\n  }\n  return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n});\nSlotClone.displayName = \"SlotClone\";\nvar Slottable = _ref => {\n  let {\n    children\n  } = _ref;\n  return /* @__PURE__ */jsx(Fragment, {\n    children\n  });\n};\nfunction isSlottable(child) {\n  return React.isValidElement(child) && child.type === Slottable;\n}\nfunction mergeProps(slotProps, childProps) {\n  const overrideProps = _objectSpread({}, childProps);\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = function () {\n          childPropValue(...arguments);\n          slotPropValue(...arguments);\n        };\n      } else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    } else if (propName === \"style\") {\n      overrideProps[propName] = _objectSpread(_objectSpread({}, slotPropValue), childPropValue);\n    } else if (propName === \"className\") {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(\" \");\n    }\n  }\n  return _objectSpread(_objectSpread({}, slotProps), overrideProps);\n}\nfunction getElementRef(element) {\n  var _Object$getOwnPropert, _Object$getOwnPropert2;\n  let getter = (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(element.props, \"ref\")) === null || _Object$getOwnPropert === void 0 ? void 0 : _Object$getOwnPropert.get;\n  let mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.ref;\n  }\n  getter = (_Object$getOwnPropert2 = Object.getOwnPropertyDescriptor(element, \"ref\")) === null || _Object$getOwnPropert2 === void 0 ? void 0 : _Object$getOwnPropert2.get;\n  mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n  return element.props.ref || element.ref;\n}\nvar Root = Slot;\nexport { Root, Slot, Slottable };","map":{"version":3,"names":["React","composeRefs","Fragment","jsx","Slot","forwardRef","props","forwardedRef","children","slotProps","_objectWithoutProperties","_excluded","childrenArray","Children","toArray","slottable","find","isSlottable","newElement","newChildren","map","child","count","only","isValidElement","SlotClone","_objectSpread","ref","cloneElement","displayName","_excluded2","childrenRef","getElementRef","mergeProps","Slottable","_ref","type","childProps","overrideProps","propName","slotPropValue","childPropValue","isHandler","test","arguments","filter","Boolean","join","element","_Object$getOwnPropert","_Object$getOwnPropert2","getter","Object","getOwnPropertyDescriptor","get","mayWarn","isReactWarning","Root"],"sources":["/home/spiderman/tek2/project-week/Pet-Wise/frontend/node_modules/@radix-ui/react-slot/src/Slot.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\nconst Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n  const childrenArray = React.Children.toArray(children);\n  const slottable = childrenArray.find(isSlottable);\n\n  if (slottable) {\n    // the new element to render is the one passed as a child of `Slottable`\n    const newElement = slottable.props.children;\n\n    const newChildren = childrenArray.map((child) => {\n      if (child === slottable) {\n        // because the new element will be the one rendered, we are only interested\n        // in grabbing its children (`newElement.props.children`)\n        if (React.Children.count(newElement) > 1) return React.Children.only(null);\n        return React.isValidElement(newElement)\n          ? (newElement.props as { children: React.ReactNode }).children\n          : null;\n      } else {\n        return child;\n      }\n    });\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {React.isValidElement(newElement)\n          ? React.cloneElement(newElement, undefined, newChildren)\n          : null}\n      </SlotClone>\n    );\n  }\n\n  return (\n    <SlotClone {...slotProps} ref={forwardedRef}>\n      {children}\n    </SlotClone>\n  );\n});\n\nSlot.displayName = 'Slot';\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\nconst SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n\n  if (React.isValidElement(children)) {\n    const childrenRef = getElementRef(children);\n    return React.cloneElement(children, {\n      ...mergeProps(slotProps, children.props as AnyProps),\n      // @ts-ignore\n      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef,\n    });\n  }\n\n  return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n});\n\nSlotClone.displayName = 'SlotClone';\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst Slottable = ({ children }: { children: React.ReactNode }) => {\n  return <>{children}</>;\n};\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(\n  child: React.ReactNode\n): child is React.ReactElement<React.ComponentProps<typeof Slottable>, typeof Slottable> {\n  return React.isValidElement(child) && child.type === Slottable;\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          childPropValue(...args);\n          slotPropValue(...args);\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element.props as { ref?: React.Ref<unknown> }).ref;\n  }\n\n  // Not DEV\n  return (element.props as { ref?: React.Ref<unknown> }).ref || (element as any).ref;\n}\n\nconst Root = Slot;\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Root,\n};\nexport type { SlotProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}